# BaekJoon

----

### JAVA Algorithm Solutions
<br><br>

# 기록 요약
| 번호  | 알고리즘            | 제목                      | 난이도 | 보기                                                         |
| ----- | ------------------- | ------------------------- | ------ | ------------------------------------------------------------ |
| 17478 | Recursive Call      | 재귀함수가 뭔가요?        | S5     | - 기저 조건 설정에 유의<br />- 재귀함수 작성시 현재 시점에서 응용가능한 것만 바라보기(플랫한 관점) |
| 1244  | -                   | 스위치 켜고 끄기          | S4     | - 조건 따라 순차적으로 처리<br />- 인덱스 유의               |
| 2493  | Stack               | 탑                        | G5     | - 문제를 반대로 해결하는 접근<br />- Stack사용<br />- Stack.size()<br />- Queue는 new LinkedList로 작성(Queue가 Interface)<br />- List, ArrayList, Queue, Stack, Vector 등의 <E>에 원래는 클래스 사용, but Wrapper 클래스 통해 Primitive Type 사용 가능(박싱<-> 언박싱) |
| 1158  | Queue               | 요세푸스 문제             | S5     | - Queue 사용<br />- 싸이클 조건 설정                         |
| 2563  | -                   | 색종이                    | S5     | - 문제  Flat하게 보기<br />- 어렵게 생각말고 2차원 배열로 쉽게 생각하기<br />- for문 설정 많아서 헷갈리면 함수 나누기 |
| 16926 | -                   | 배열 돌리기 1             | S2     | - 다시 해보기★<br />- 상하좌우를 배열로 미리 담아두고 면 단위로 움직이기 |
| 16935 | -                   | 배열 돌리기3              | S2     | - 3,4번 다시 해보기. 마무리짓는 힘기르기★<br />- 문제 예시 마지막까지 잘 읽기<br />- 배열의 행과 열을 중간에 바꿀 수 있다. |
| 2961  | Combination         | 도영이가 만든 맛있는 음식 | S1     | - 조합 문제 : 조합은 순서 처리가 없다. <br />- 문제 꼼꼼히 > 기저조건에서 아무것도 없을 때 조건빠짐..! |
| 3040  | DFS                 | 백설공주와 일곱 난쟁이    | B2     | - DFS<br />- 어디에 결과값을 처리할지 고민하기. 되도록이면 기저조건에서 값 처리. |
| 15686 | DFS                 | 치킨배달                  | G5     | - DFS<br />- 입력받을 때 처리해놓으면, 다음이 쉽다<br />- 여전히 ArrayIndexOutOfBounds 주의! |
| 2605  | -                   | 줄 세우기                 | B2     | - 주어진 조건에 따라 풀면 되는 문제<br />- ArrayList의 add 사용시, index를 이용한 값 설정 주의 |
| 2839  | 중복조합            | 설탕 배달                 | B1     | - 중복조합 > 조합은 해당 인덱스에서 가능한 것  다 고르고 다음 순서로 넘어갔을 땐 겹치지 않기 위해 start부터 시작(매개변수) |
| 2578  | 완전탐색            | 빙고                      | S5     | - 빙고 체크된 칸 판별하는 방법<br />- 각 경우의 수 조건 꼼꼼히 따지기 |
| 1074  | Recursive Call      | Z                         | S1     | - 완전 탐색이 아니라 원하는 부분을 집중적으로 찾기<br />- 재귀로 더 간단히 풀 수 있음<br />- Math.power(double, double)  > 리턴값도 double이라 int로 명시적 형변환 필요.<br />- n* n * 3 /4 하는 과정에서 integer 범위( -2147483648 ~ 2147483647)를 벗어남 <br />   > long을 쓸 수도 있지만, 계산이 정확하지 않음 . 그래서 우선 4를 나눈 뒤 곱함. |
| 1992  | Divided and conquer | 쿼드트리                  | S1     | - 분할 정복<br />- 재귀 연습 더하기<br />- 인덱스 설정에 유의 |
| 1987  | DFS                 | 알파벳                    | G4     | - DFS > visited 체크하고 재귀 돌리고 체크 풀기<br />- DFS는 반복문이 필수는 아님.(시작이 정해진 경우는 반복문을 굳이 필요하지 않음)<br />- 기저조건에 대한 강박 버리기<br />- String은 생성하는 방식에 따라 결과가 다르게 나올수 있으니 equals를 쓰자. |
| 1759  | Combination         | 암호 만들기               | G5     | - 조합<br />- Character.toString  : char -> string<br />- String str; str.charAt(index) : string -> char<br />- Arrays.sort();<br />- return 위치 유념 |

